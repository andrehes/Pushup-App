<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Push-up Coach (MVP)</title>

  <meta name="theme-color" content="#0ea5e9" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a2c;
      --ink: #e6f0ff;
      --muted: #9fb4d1;
      --accent: #0ea5e9;
      --warn: #f59e0b;
      --bad: #ef4444;
      --good: #10b981;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    header { padding: 16px; text-align: center; background: linear-gradient(180deg, rgba(14,165,233,0.08), transparent); }
    h1 { margin: 0; font-size: clamp(18px, 5vw, 24px); }
    main { max-width: 920px; margin: 0 auto; padding: 12px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; }
    button, label.file { border: none; border-radius: 12px; padding: 12px 14px; font-size: 15px; font-weight: 600; cursor: pointer; }
    button.primary { background: var(--accent); color: #00131f; }
    button.danger { background: #23314f; color: #ffb4b4; }
    label.file { background: #16233e; color: var(--ink); }
    input[type=file] { display: none; }
    .hint { color: var(--muted); font-size: 13px; margin-top: 6px; }
    .hud { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 10px; }
    .stat { background: var(--panel); border-radius: 10px; padding: 10px; }
    .big { font-size: 28px; font-weight: 800; }
    .warns { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { font-size: 12px; padding: 6px 8px; border-radius: 999px; background: #1a2746; color: var(--muted); }
    .chip.bad { background: rgba(239,68,68,.12); color: #ffb4b4; }
    canvas { width: 100%; height: auto; border-radius: 10px; background: #000; display: block; }
    .angles { font-size: 12px; color: var(--muted); display: grid; grid-template-columns: repeat(3,1fr); gap: 6px; margin-top: 6px; }
    .angles div { background: #0f1629; border-radius: 8px; padding: 6px; text-align: center; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.4.0/dist/pose-detection.min.js"></script>
</head>
<body>
  <header>
    <h1>Push-up Coach (MVP)</h1>
  </header>

  <main>
    <div class="controls">
      <button id="btnCamera" class="primary">Kamera starten</button>
      <label class="file">Video hochladen<input id="fileInput" type="file" accept="video/*"></label>
      <button id="btnReset" class="danger">Reset</button>
      <button id="btnFeedback">Feedback erzeugen</button>
    </div>
    <div class="hint">Seitliche Profilansicht, gute Beleuchtung. Alles bleibt lokal – kein Upload.</div>
    <canvas id="canvas" width="640" height="480"></canvas>
    <div class="angles">
      <div>Ellbogen ∠: <span id="elbowAng">–</span>°</div>
      <div>Körperlinie ∠: <span id="bodyAng">–</span>°</div>
      <div>Hüfte ∠: <span id="hipAng">–</span>°</div>
    </div>
    <div class="hud">
      <div class="stat"><div>Wiederholungen</div><div class="big" id="reps">0</div></div>
      <div class="stat"><div>Status</div><div id="status">Bereit</div></div>
      <div class="stat"><div>Warnungen</div><div class="warns" id="warns"><span class="chip">–</span></div></div>
      <div class="stat"><div>Fehler gesamt</div>
        <div>Hüfte hängt: <b id="cHip">0</b></div>
        <div>Schiefe Linie: <b id="cMis">0</b></div>
        <div>Nicht tief genug: <b id="cShal">0</b></div>
      </div>
    </div>
  </main>

  <!-- Safari requires the video element to remain in the layout so that frames
       can be rendered to the canvas. Instead of using display:none, move the
       element off-screen and make it transparent. -->
<video id="video" style="opacity:0; position:absolute; left:-9999px; top:-9999px;" 
       playsinline 
       autoplay 
       allow="camera" 
       muted></video>


  <script>
    const CANVAS = document.getElementById('canvas');
    const CTX = CANVAS.getContext('2d');
    const VIDEO = document.getElementById('video');

    const btnCamera = document.getElementById('btnCamera');
    const btnReset = document.getElementById('btnReset');
    const fileInput = document.getElementById('fileInput');

    const repsEl = document.getElementById('reps');
    const statusEl = document.getElementById('status');
    const warnsEl = document.getElementById('warns');

    const elbowAngEl = document.getElementById('elbowAng');
    const bodyAngEl = document.getElementById('bodyAng');
    const hipAngEl  = document.getElementById('hipAng');

    const cHipEl = document.getElementById('cHip');
    const cMisEl = document.getElementById('cMis');
    const cShalEl = document.getElementById('cShal');

    const THRESH = { bottomElbow: 70, topElbow: 160, goodBodyLine: 165, goodHip: 165 };
    let detector = null;
    let running = false;
    let usingCamera = false;
    let mediaStream = null;
    let phase = 'up';
    let reps = 0;
    let totalErrors = { HIP_SAG: 0, MISALIGN: 0, SHALLOW: 0 };
    let currentRep = { sawBottom: false, hipSag: false, misalign: false };
    let lastWarnings = [];

    async function ensureDetector() {
      if (detector) return detector;
      const backends = ['webgl', 'wasm', 'cpu'];
      let ready = false;
      for (const b of backends) {
        try {
          await tf.setBackend(b);
          await tf.ready();
          ready = true;
          break;
        } catch (err) {
          console.warn('Backend init failed for', b, err);
        }
      }
      if (!ready) {
        statusEl.textContent = 'TensorFlow-Backend nicht verfügbar';
        throw new Error('No TensorFlow backend available');
      }
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
        enableSmoothing: true
      });
      return detector;
    }

    function stopStream(stream) {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
    }

    function stopEverything() {
      running = false;
      if (usingCamera) stopStream(mediaStream);
      VIDEO.pause();
      VIDEO.srcObject = null;
      VIDEO.removeAttribute('src');
      VIDEO.load();
    }

    async function startCamera() {
  stopEverything();
  usingCamera = true;
  
  if (!navigator.mediaDevices || !isSecureContext) {
    statusEl.textContent = 'Kamera nicht verfügbar – über HTTPS/localhost starten';
    return;
  }

  try {
    // First try with ideal environment-facing camera
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 },
        facingMode: { ideal: "environment" }
      }
    });

    VIDEO.setAttribute('playsinline', '');
    VIDEO.setAttribute('autoplay', '');
    VIDEO.muted = true;
    VIDEO.srcObject = mediaStream;

    // Wait for video to be ready
    await new Promise((resolve) => {
      VIDEO.onloadedmetadata = () => {
        resolve();
      };
    });

    // Check if we got a valid video stream
    if (VIDEO.videoWidth === 0) {
      console.warn('Fallback auf Frontkamera');
      stopStream(mediaStream);
      
      // Try again with user-facing camera
      mediaStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false
      });
      
      VIDEO.srcObject = mediaStream;
      await new Promise((resolve) => {
        VIDEO.onloadedmetadata = () => {
          resolve();
        };
      });
    }

    try {
      await VIDEO.play();
      statusEl.textContent = 'Kamera aktiv';
      run();
    } catch (playErr) {
      statusEl.textContent = 'Video-Start Fehler: ' + playErr.message;
      console.warn('Video play error:', playErr);
    }

  } catch (err) {
    statusEl.textContent = err.name === 'NotAllowedError'
      ? 'Zugriff auf Kamera verweigert'
      : 'Kamera-Fehler: ' + err.message;
    console.error('Camera error:', err);
  }
}

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: { ideal: "environment" } }
        });
      } catch (err) {
        statusEl.textContent = err.name === 'NotAllowedError'
          ? 'Zugriff auf Kamera verweigert'
          : 'Kamera-Fehler: ' + err.message;
        console.error(err);
        return;
      }

      VIDEO.setAttribute('playsinline', '');
      VIDEO.muted = true;
      VIDEO.srcObject = mediaStream;

      VIDEO.onloadedmetadata = async () => {
        if (VIDEO.videoWidth === 0) {
          console.warn('Fallback auf Frontkamera');
          stopStream(mediaStream);
          try {
            mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
            VIDEO.srcObject = mediaStream;
          } catch (err) {
            statusEl.textContent = 'Kamera-Fehler: ' + err.message;
            console.error(err);
            return;
          }
        }
        try {
          await VIDEO.play();
          statusEl.textContent = 'Kamera aktiv';
          run();
        } catch (err) {
          statusEl.textContent = 'Autoplay blockiert: ' + err.message;
          console.warn('Autoplay blockiert', err);
        }
      };

    }

    function toMap(kps) { const m={}; kps.forEach(k=>m[k.name]=k); return m; }
    function midPoint(a,b){return(!a||!b)?null:{x:(a.x+b.x)/2,y:(a.y+b.y)/2,score:Math.min(a.score??0,b.score??0)};}
    function angleDeg(a,b,c){if(!a||!b||!c)return null;let bax=a.x-b.x,bay=a.y-b.y,bcx=c.x-b.x,bcy=c.y-b.y;let dot=bax*bcx+bay*bcy;let mag1=Math.hypot(bax,bay),mag2=Math.hypot(bcx,bcy);if(mag1===0||mag2===0)return null;let cos=dot/(mag1*mag2);cos=Math.max(-1,Math.min(1,cos));return Math.round((Math.acos(cos)*180)/Math.PI);}

    function drawVideo() { CTX.drawImage(VIDEO, 0, 0, CANVAS.width, CANVAS.height); }
    function drawKeypoint(kp,c='#0ea5e9'){ if(!kp||(kp.score??0)<0.3)return; CTX.fillStyle=c; CTX.beginPath(); CTX.arc(kp.x,kp.y,4,0,Math.PI*2); CTX.fill(); }
    function drawLine(a,b,c='#85d7ff'){ if(!a||!b) return; if((a.score??0)<0.3||(b.score??0)<0.3)return; CTX.strokeStyle=c; CTX.beginPath(); CTX.moveTo(a.x,a.y); CTX.lineTo(b.x,b.y); CTX.stroke(); }

    function updateRepLogic(angles) {
      const bodyOk = angles.bodyLine && angles.bodyLine > THRESH.goodBodyLine;
      const hipOk  = angles.hip && angles.hip > THRESH.goodHip;
      lastWarnings = [];
      if (!bodyOk) lastWarnings.push('Körperlinie!');
      if (!hipOk) lastWarnings.push('Hüfte hängt!');
      if (!hipOk) currentRep.hipSag = true;
      if (!bodyOk) currentRep.misalign = true;
      const e = angles.elbow;
      if (!e) return;
      if (phase === 'up') {
        if (e < 120) {
          phase = 'down';
          currentRep = { sawBottom: false, hipSag: !hipOk, misalign: !bodyOk };
        }
      } else {
        if (e < THRESH.bottomElbow) currentRep.sawBottom = true;
        if (e > THRESH.topElbow) {
          reps++;
          repsEl.textContent = reps;
          phase = 'up';
          if (!currentRep.sawBottom) totalErrors.SHALLOW++;
          if (currentRep.hipSag) totalErrors.HIP_SAG++;
          if (currentRep.misalign) totalErrors.MISALIGN++;
          cHipEl.textContent = totalErrors.HIP_SAG;
          cMisEl.textContent = totalErrors.MISALIGN;
          cShalEl.textContent = totalErrors.SHALLOW;
        }
      }
    }

    function renderWarnings() {
      warnsEl.innerHTML = '';
      if (!lastWarnings.length) { warnsEl.innerHTML='<span class="chip">Keine</span>'; return; }
      lastWarnings.forEach(w=>{ const s=document.createElement('span'); s.className='chip bad'; s.textContent=w; warnsEl.appendChild(s); });
    }

    async function run() {
      await ensureDetector();
      running = true;
      const loop = async () => {
        if (!running) return;
        drawVideo();
        let poses = [];
        try { poses = await detector.estimatePoses(VIDEO, { maxPoses: 1, flipHorizontal: false }); } catch {}
        if (poses[0]?.keypoints) {
          const map = toMap(poses[0].keypoints);
          const mid = {
            shoulder: midPoint(map.left_shoulder,map.right_shoulder),
            elbow: midPoint(map.left_elbow,map.right_elbow),
            wrist: midPoint(map.left_wrist,map.right_wrist),
            hip: midPoint(map.left_hip,map.right_hip),
            knee: midPoint(map.left_knee,map.right_knee),
            ankle: midPoint(map.left_ankle,map.right_ankle)
          };
          const angles = {
            elbow: angleDeg(mid.shoulder, mid.elbow, mid.wrist),
            bodyLine: angleDeg(mid.shoulder, mid.hip, mid.ankle),
            hip: angleDeg(mid.shoulder, mid.hip, mid.knee)
          };
          elbowAngEl.textContent = angles.elbow ?? '–';
          bodyAngEl.textContent = angles.bodyLine ?? '–';
          hipAngEl.textContent = angles.hip ?? '–';
          updateRepLogic(angles);
          renderWarnings();
          ['shoulder','elbow','wrist','hip','knee','ankle'].forEach(n=>drawKeypoint(mid[n]));
          drawLine(mid.shoulder, mid.hip);
          drawLine(mid.hip, mid.knee);
          drawLine(mid.knee, mid.ankle);
          drawLine(mid.shoulder, mid.elbow);
          drawLine(mid.elbow, mid.wrist);
        }
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    function resetAll() {
      stopEverything();
      phase='up'; reps=0;
      totalErrors={ HIP_SAG:0, MISALIGN:0, SHALLOW:0 };
      repsEl.textContent='0'; cHipEl.textContent='0'; cMisEl.textContent='0'; cShalEl.textContent='0';
      elbowAngEl.textContent='–'; bodyAngEl.textContent='–'; hipAngEl.textContent='–';
      warnsEl.innerHTML='<span class="chip">–</span>';
      CTX.clearRect(0,0,CANVAS.width,CANVAS.height);
    }

    btnCamera.addEventListener('click', startCamera);
    btnReset.addEventListener('click', resetAll);
    fileInput.addEventListener('change', e => { const f=e.target.files[0]; if(f) handleFile(f); });

    async function handleFile(file) {
      stopEverything();
      usingCamera = false;
      const url = URL.createObjectURL(file);
      VIDEO.src = url;
      VIDEO.muted = true;
      VIDEO.setAttribute('playsinline','');
      await VIDEO.play().catch(()=>{});
      statusEl.textContent = 'Lokales Video';
      run();
    }
  </script>
</body>
</html>

